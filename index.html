<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport"
content="width=device-width,height=device-height,initial-scale=1.0,user-scalable=no">

<title>Ragdoll Fists Mobile</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  background: #111;
  touch-action: none;
  user-select: none;
}

#ui {
  position: fixed;
  top: 10px;
  left: 0;
  width: 100%;
  display: flex;
  justify-content: space-around;
  color: white;
  font-family: sans-serif;
  z-index: 10;
}

.bar {
  width: 40%;
  height: 14px;
  background: #333;
}

.fill {
  height: 100%;
  background: red;
}
</style>
</head>
<body>

<div id="ui">
  <div>
    PLAYER
    <div class="bar"><div id="php" class="fill"></div></div>
  </div>
  <div>
    ENEMY
    <div class="bar"><div id="ehp" class="fill"></div></div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<script>
const { Engine, Render, World, Bodies, Body, Constraint } = Matter;

const engine = Engine.create();
engine.world.gravity.y = 1.2;

const render = Render.create({
  element: document.body,
  engine,
  options: {
    wireframes: false,
    background: "#111"
  }
});

function resize() {
  render.canvas.width = document.documentElement.clientWidth;
  render.canvas.height = document.documentElement.clientHeight;
}
window.addEventListener("resize", resize);
resize();

const ground = Bodies.rectangle(
  render.canvas.width / 2,
  render.canvas.height - 30,
  render.canvas.width,
  60,
  { isStatic: true }
);

World.add(engine.world, ground);

function ragdoll(x, y, color) {
  const torso = Bodies.rectangle(x, y, 30, 50);
  const head = Bodies.circle(x, y - 40, 15);
  const armL = Bodies.rectangle(x - 25, y, 40, 10);
  const armR = Bodies.rectangle(x + 25, y, 40, 10);
  const legL = Bodies.rectangle(x - 10, y + 50, 10, 40);
  const legR = Bodies.rectangle(x + 10, y + 50, 10, 40);

  const parts = [torso, head, armL, armR, legL, legR];
  parts.forEach(p => p.render.fillStyle = color);

  const joints = [
    Constraint.create({ bodyA: torso, bodyB: head, length: 10 }),
    Constraint.create({ bodyA: torso, bodyB: armL, length: 25 }),
    Constraint.create({ bodyA: torso, bodyB: armR, length: 25 }),
    Constraint.create({ bodyA: torso, bodyB: legL, length: 30 }),
    Constraint.create({ bodyA: torso, bodyB: legR, length: 30 })
  ];

  World.add(engine.world, [...parts, ...joints]);

  return { torso, head, armL, armR, legL, legR };
}

const player = ragdoll(150, 300, "red");
const enemy  = ragdoll(350, 300, "dodgerblue");

let php = 100, ehp = 100;

function updateHP() {
  document.getElementById("php").style.width = php + "%";
  document.getElementById("ehp").style.width = ehp + "%";
}

updateHP();

/* --- Touch Controls --- */
let sx = 0, sy = 0;

document.addEventListener("touchstart", e => {
  sx = e.touches[0].clientX;
  sy = e.touches[0].clientY;
});

document.addEventListener("touchend", e => {
  const dx = e.changedTouches[0].clientX - sx;
  const dy = e.changedTouches[0].clientY - sy;

  if (Math.abs(dx) > Math.abs(dy)) {
    if (dx > 40) Body.applyForce(player.torso, player.torso.position, { x: 0.05, y: 0 });
    if (dx < -40) Body.applyForce(player.torso, player.torso.position, { x: -0.05, y: 0 });
  } else {
    if (dy < -40) Body.applyForce(player.torso, player.torso.position, { x: 0, y: -0.15 });
    if (dy > 40) Body.scale(player.torso, 1, 0.8);
  }

  if (Math.abs(dx) < 20 && Math.abs(dy) < 20) {
    const limb = Math.random() > 0.5 ? player.armR : player.legR;
    Body.applyForce(limb, limb.position, { x: 0.15, y: -0.05 });
    ehp = Math.max(0, ehp - 5);
    updateHP();
  }
});

/* Enemy AI */
setInterval(() => {
  Body.applyForce(enemy.torso, enemy.torso.position, { x: -0.02, y: 0 });
  if (Math.random() < 0.3) {
    Body.applyForce(enemy.armL, enemy.armL.position, { x: -0.1, y: -0.05 });
    php = Math.max(0, php - 3);
    updateHP();
  }
}, 600);

Engine.run(engine);
Render.run(render);
</script>
</body>
</html>            background: #ff3e3e;
            transition: width 0.2s;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.5);
            font-size: 12px;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="ui">
        <div>PLAYER <div class="health-bar"><div id="p1-health" class="health-fill"></div></div></div>
        <div>ENEMY <div class="health-bar"><div id="p2-health" class="health-fill"></div></div></div>
    </div>
    
    <div id="instructions">SWIPE: MOVE/JUMP | TAP: ATTACK/PICKUP</div>

    <script>
        const { Engine, Render, Runner, World, Bodies, Body, Composite, Constraint, Vector, Events } = Matter;

        // --- CONFIGURATION ---
        const CONFIG = {
            width: window.innerWidth,
            height: window.innerHeight,
            gravity: 1.2,
            friction: 0.1,
            playerColor: '#3498db',
            enemyColor: '#e74c3c'
        };

        // --- ENGINE SETUP ---
        const engine = Engine.create({ enableSleeping: true });
        const world = engine.world;
        engine.world.gravity.y = CONFIG.gravity;

        const render = Render.create({
            element: document.body,
            engine: engine,
            options: {
                width: CONFIG.width,
                height: CONFIG.height,
                wireframes: false,
                background: '#1a1a1a'
            }
        });

        Render.run(render);
        const runner = Runner.create();
        Runner.run(runner, engine);

        // --- GROUND ---
        const ground = Bodies.rectangle(CONFIG.width / 2, CONFIG.height + 25, CONFIG.width, 100, { isStatic: true, friction: 1 });
        World.add(world, ground);

        // --- RAGDOLL CLASS ---
        class Ragdoll {
            constructor(x, y, color, isPlayer = false) {
                this.color = color;
                this.isPlayer = isPlayer;
                this.health = 100;
                this.group = Body.nextGroup(true);
                
                // Parts
                const head = Bodies.circle(x, y - 60, 15, { collisionFilter: { group: this.group }, friction: 0.5, render: { fillStyle: color } });
                const torso = Bodies.rectangle(x, y - 20, 30, 50, { collisionFilter: { group: this.group }, friction: 0.5, render: { fillStyle: color } });
                
                const lUpperArm = Bodies.rectangle(x - 25, y - 35, 10, 30, { collisionFilter: { group: this.group }, render: { fillStyle: color } });
                const lLowerArm = Bodies.rectangle(x - 25, y - 10, 8, 25, { collisionFilter: { group: this.group }, render: { fillStyle: color } });
                
                const rUpperArm = Bodies.rectangle(x + 25, y - 35, 10, 30, { collisionFilter: { group: this.group }, render: { fillStyle: color } });
                const rLowerArm = Bodies.rectangle(x + 25, y - 10, 8, 25, { collisionFilter: { group: this.group }, render: { fillStyle: color } });

                const lLeg = Bodies.rectangle(x - 10, y + 20, 12, 40, { collisionFilter: { group: this.group }, render: { fillStyle: color } });
                const rLeg = Bodies.rectangle(x + 10, y + 20, 12, 40, { collisionFilter: { group: this.group }, render: { fillStyle: color } });

                this.mainBody = torso;
                this.limbs = [lLowerArm, rLowerArm, lLeg, rLeg];

                // Constraints (Joints)
                const neck = Constraint.create({ bodyA: head, pointA: { x: 0, y: 15 }, bodyB: torso, pointB: { x: 0, y: -25 }, stiffness: 0.6 });
                const lShoulder = Constraint.create({ bodyA: torso, pointA: { x: -15, y: -20 }, bodyB: lUpperArm, pointB: { x: 0, y: -15 }, stiffness: 0.6 });
                const rShoulder = Constraint.create({ bodyA: torso, pointA: { x: 15, y: -20 }, bodyB: rUpperArm, pointB: { x: 0, y: -15 }, stiffness: 0.6 });
                const lElbow = Constraint.create({ bodyA: lUpperArm, pointA: { x: 0, y: 15 }, bodyB: lLowerArm, pointB: { x: 0, y: -12 }, stiffness: 0.6 });
                const rElbow = Constraint.create({ bodyA: rUpperArm, pointA: { x: 0, y: 15 }, bodyB: rLowerArm, pointB: { x: 0, y: -12 }, stiffness: 0.6 });
                const lHip = Constraint.create({ bodyA: torso, pointA: { x: -10, y: 25 }, bodyB: lLeg, pointB: { x: 0, y: -20 }, stiffness: 0.4 });
                const rHip = Constraint.create({ bodyA: torso, pointA: { x: 10, y: 25 }, bodyB: rLeg, pointB: { x: 0, y: -20 }, stiffness: 0.4 });

                this.composite = Composite.create({
                    bodies: [head, torso, lUpperArm, lLowerArm, rUpperArm, rLowerArm, lLeg, rLeg],
                    constraints: [neck, lShoulder, rShoulder, lElbow, rElbow, lHip, rHip]
                });

                World.add(world, this.composite);
            }

            move(dir) {
                Body.applyForce(this.mainBody, this.mainBody.position, { x: dir * 0.005, y: 0 });
            }

            jump() {
                if (Math.abs(this.mainBody.velocity.y) < 1) {
                    Body.applyForce(this.mainBody, this.mainBody.position, { x: 0, y: -0.05 });
                }
            }

            attack(targetPos) {
                const limb = this.limbs[Math.floor(Math.random() * this.limbs.length)];
                const forceVec = Vector.mult(Vector.normalise(Vector.sub(targetPos, limb.position)), 0.02);
                Body.applyForce(limb, limb.position, forceVec);
            }

            crouch(active) {
                this.mainBody.frictionAir = active ? 0.1 : 0.01;
                Body.scale(this.mainBody, 1, active ? 0.8 : 1.25);
            }
        }

        // --- WEAPONS ---
        function createWeapon(x, y) {
            const weapon = Bodies.rectangle(x, y, 40, 10, { 
                render: { fillStyle: '#f1c40f' },
                label: 'weapon'
            });
            World.add(world, weapon);
            return weapon;
        }

        const player = new Ragdoll(200, CONFIG.height - 100, CONFIG.playerColor, true);
        const enemy = new Ragdoll(CONFIG.width - 200, CONFIG.height - 100, CONFIG.enemyColor);
        let activeWeapon = createWeapon(CONFIG.width / 2, CONFIG.height - 50);

        // --- GESTURE CONTROLS ---
        let touchStart = { x: 0, y: 0 };
        let touchStartTime = 0;

        window.addEventListener('touchstart', (e) => {
            touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            touchStartTime = Date.now();
        });

        window.addEventListener('touchend', (e) => {
            const touchEnd = { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
            const dx = touchEnd.x - touchStart.x;
            const dy = touchEnd.y - touchStart.y;
            const duration = Date.now() - touchStartTime;

            if (duration < 200 && Math.abs(dx) < 20 && Math.abs(dy) < 20) {
                // TAP: Attack or Pickup
                const distToWeapon = Vector.magnitude(Vector.sub(touchEnd, activeWeapon.position));
                if (distToWeapon < 60) {
                    Constraint.create({
                        bodyA: player.limbs[0],
                        bodyB: activeWeapon,
                        stiffness: 0.1,
                        length: 5,
                        render: { visible: true }
                    });
                } else {
                    player.attack(touchEnd);
                }
            } else {
                // SWIPES
                if (Math.abs(dx) > Math.abs(dy)) {
                    player.move(dx > 0 ? 1 : -1);
                } else {
                    if (dy < -30) player.jump();
                    if (dy > 30) player.crouch(true);
                    setTimeout(() => player.crouch(false), 500);
                }
            }
        });

        // --- AI LOGIC ---
        Events.on(engine, 'beforeUpdate', () => {
            // Simple Follow AI
            const dist = enemy.mainBody.position.x - player.mainBody.position.x;
            if (Math.abs(dist) > 100) {
                enemy.move(dist > 0 ? -0.4 : 0.4);
            } else {
                if (Math.random() > 0.95) enemy.attack(player.mainBody.position);
            }
            
            // Boundary checks
            [player, enemy].forEach(p => {
                if (p.mainBody.position.x < 0) Body.setPosition(p.mainBody, { x: 20, y: p.mainBody.position.y });
                if (p.mainBody.position.x > CONFIG.width) Body.setPosition(p.mainBody, { x: CONFIG.width - 20, y: p.mainBody.position.y });
            });
        });

        // --- COLLISION DAMAGE ---
        Events.on(engine, 'collisionStart', (event) => {
            event.pairs.forEach(pair => {
                const bodies = [pair.bodyA, pair.bodyB];
                const isEnemyPart = bodies.some(b => enemy.composite.bodies.includes(b));
                const isPlayerPart = bodies.some(b => player.composite.bodies.includes(b));
                
                if (isEnemyPart && isPlayerPart && pair.collision.depth > 2) {
                    const damage = pair.collision.depth * 2;
                    if (pair.bodyA.speed > 5 || pair.bodyB.speed > 5) {
                        // Determine who hit whom based on speed
                        if (player.mainBody.position.x < enemy.mainBody.position.x) {
                            enemy.health -= damage;
                        } else {
                            player.health -= damage;
                        }
                        updateUI();
                    }
                }
            });
        });

        function updateUI() {
            document.getElementById('p1-health').style.width = Math.max(0, player.health) + '%';
            document.getElementById('p2-health').style.width = Math.max(0, enemy.health) + '%';
            
            if (player.health <= 0 || enemy.health <= 0) {
                alert(player.health <= 0 ? "ENEMY WINS!" : "PLAYER WINS!");
                location.reload();
            }
        }

    </script>
</body>
</html>
