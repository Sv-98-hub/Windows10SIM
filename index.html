<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ragdoll Strike Mobile</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #1a1a1a;
            font-family: sans-serif;
            touch-action: none;
        }
        #ui {
            position: absolute;
            top: 20px;
            width: 100%;
            display: flex;
            justify-content: space-around;
            pointer-events: none;
            color: white;
            font-weight: bold;
            text-transform: uppercase;
        }
        .health-bar {
            width: 150px;
            height: 15px;
            background: #444;
            border: 2px solid #fff;
        }
        .health-fill {
            width: 100%;
            height: 100%;
            background: #ff3e3e;
            transition: width 0.2s;
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.5);
            font-size: 12px;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="ui">
        <div>PLAYER <div class="health-bar"><div id="p1-health" class="health-fill"></div></div></div>
        <div>ENEMY <div class="health-bar"><div id="p2-health" class="health-fill"></div></div></div>
    </div>
    
    <div id="instructions">SWIPE: MOVE/JUMP | TAP: ATTACK/PICKUP</div>

    <script>
        const { Engine, Render, Runner, World, Bodies, Body, Composite, Constraint, Vector, Events } = Matter;

        // --- CONFIGURATION ---
        const CONFIG = {
            width: window.innerWidth,
            height: window.innerHeight,
            gravity: 1.2,
            friction: 0.1,
            playerColor: '#3498db',
            enemyColor: '#e74c3c'
        };

        // --- ENGINE SETUP ---
        const engine = Engine.create({ enableSleeping: true });
        const world = engine.world;
        engine.world.gravity.y = CONFIG.gravity;

        const render = Render.create({
            element: document.body,
            engine: engine,
            options: {
                width: CONFIG.width,
                height: CONFIG.height,
                wireframes: false,
                background: '#1a1a1a'
            }
        });

        Render.run(render);
        const runner = Runner.create();
        Runner.run(runner, engine);

        // --- GROUND ---
        const ground = Bodies.rectangle(CONFIG.width / 2, CONFIG.height + 25, CONFIG.width, 100, { isStatic: true, friction: 1 });
        World.add(world, ground);

        // --- RAGDOLL CLASS ---
        class Ragdoll {
            constructor(x, y, color, isPlayer = false) {
                this.color = color;
                this.isPlayer = isPlayer;
                this.health = 100;
                this.group = Body.nextGroup(true);
                
                // Parts
                const head = Bodies.circle(x, y - 60, 15, { collisionFilter: { group: this.group }, friction: 0.5, render: { fillStyle: color } });
                const torso = Bodies.rectangle(x, y - 20, 30, 50, { collisionFilter: { group: this.group }, friction: 0.5, render: { fillStyle: color } });
                
                const lUpperArm = Bodies.rectangle(x - 25, y - 35, 10, 30, { collisionFilter: { group: this.group }, render: { fillStyle: color } });
                const lLowerArm = Bodies.rectangle(x - 25, y - 10, 8, 25, { collisionFilter: { group: this.group }, render: { fillStyle: color } });
                
                const rUpperArm = Bodies.rectangle(x + 25, y - 35, 10, 30, { collisionFilter: { group: this.group }, render: { fillStyle: color } });
                const rLowerArm = Bodies.rectangle(x + 25, y - 10, 8, 25, { collisionFilter: { group: this.group }, render: { fillStyle: color } });

                const lLeg = Bodies.rectangle(x - 10, y + 20, 12, 40, { collisionFilter: { group: this.group }, render: { fillStyle: color } });
                const rLeg = Bodies.rectangle(x + 10, y + 20, 12, 40, { collisionFilter: { group: this.group }, render: { fillStyle: color } });

                this.mainBody = torso;
                this.limbs = [lLowerArm, rLowerArm, lLeg, rLeg];

                // Constraints (Joints)
                const neck = Constraint.create({ bodyA: head, pointA: { x: 0, y: 15 }, bodyB: torso, pointB: { x: 0, y: -25 }, stiffness: 0.6 });
                const lShoulder = Constraint.create({ bodyA: torso, pointA: { x: -15, y: -20 }, bodyB: lUpperArm, pointB: { x: 0, y: -15 }, stiffness: 0.6 });
                const rShoulder = Constraint.create({ bodyA: torso, pointA: { x: 15, y: -20 }, bodyB: rUpperArm, pointB: { x: 0, y: -15 }, stiffness: 0.6 });
                const lElbow = Constraint.create({ bodyA: lUpperArm, pointA: { x: 0, y: 15 }, bodyB: lLowerArm, pointB: { x: 0, y: -12 }, stiffness: 0.6 });
                const rElbow = Constraint.create({ bodyA: rUpperArm, pointA: { x: 0, y: 15 }, bodyB: rLowerArm, pointB: { x: 0, y: -12 }, stiffness: 0.6 });
                const lHip = Constraint.create({ bodyA: torso, pointA: { x: -10, y: 25 }, bodyB: lLeg, pointB: { x: 0, y: -20 }, stiffness: 0.4 });
                const rHip = Constraint.create({ bodyA: torso, pointA: { x: 10, y: 25 }, bodyB: rLeg, pointB: { x: 0, y: -20 }, stiffness: 0.4 });

                this.composite = Composite.create({
                    bodies: [head, torso, lUpperArm, lLowerArm, rUpperArm, rLowerArm, lLeg, rLeg],
                    constraints: [neck, lShoulder, rShoulder, lElbow, rElbow, lHip, rHip]
                });

                World.add(world, this.composite);
            }

            move(dir) {
                Body.applyForce(this.mainBody, this.mainBody.position, { x: dir * 0.005, y: 0 });
            }

            jump() {
                if (Math.abs(this.mainBody.velocity.y) < 1) {
                    Body.applyForce(this.mainBody, this.mainBody.position, { x: 0, y: -0.05 });
                }
            }

            attack(targetPos) {
                const limb = this.limbs[Math.floor(Math.random() * this.limbs.length)];
                const forceVec = Vector.mult(Vector.normalise(Vector.sub(targetPos, limb.position)), 0.02);
                Body.applyForce(limb, limb.position, forceVec);
            }

            crouch(active) {
                this.mainBody.frictionAir = active ? 0.1 : 0.01;
                Body.scale(this.mainBody, 1, active ? 0.8 : 1.25);
            }
        }

        // --- WEAPONS ---
        function createWeapon(x, y) {
            const weapon = Bodies.rectangle(x, y, 40, 10, { 
                render: { fillStyle: '#f1c40f' },
                label: 'weapon'
            });
            World.add(world, weapon);
            return weapon;
        }

        const player = new Ragdoll(200, CONFIG.height - 100, CONFIG.playerColor, true);
        const enemy = new Ragdoll(CONFIG.width - 200, CONFIG.height - 100, CONFIG.enemyColor);
        let activeWeapon = createWeapon(CONFIG.width / 2, CONFIG.height - 50);

        // --- GESTURE CONTROLS ---
        let touchStart = { x: 0, y: 0 };
        let touchStartTime = 0;

        window.addEventListener('touchstart', (e) => {
            touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            touchStartTime = Date.now();
        });

        window.addEventListener('touchend', (e) => {
            const touchEnd = { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
            const dx = touchEnd.x - touchStart.x;
            const dy = touchEnd.y - touchStart.y;
            const duration = Date.now() - touchStartTime;

            if (duration < 200 && Math.abs(dx) < 20 && Math.abs(dy) < 20) {
                // TAP: Attack or Pickup
                const distToWeapon = Vector.magnitude(Vector.sub(touchEnd, activeWeapon.position));
                if (distToWeapon < 60) {
                    Constraint.create({
                        bodyA: player.limbs[0],
                        bodyB: activeWeapon,
                        stiffness: 0.1,
                        length: 5,
                        render: { visible: true }
                    });
                } else {
                    player.attack(touchEnd);
                }
            } else {
                // SWIPES
                if (Math.abs(dx) > Math.abs(dy)) {
                    player.move(dx > 0 ? 1 : -1);
                } else {
                    if (dy < -30) player.jump();
                    if (dy > 30) player.crouch(true);
                    setTimeout(() => player.crouch(false), 500);
                }
            }
        });

        // --- AI LOGIC ---
        Events.on(engine, 'beforeUpdate', () => {
            // Simple Follow AI
            const dist = enemy.mainBody.position.x - player.mainBody.position.x;
            if (Math.abs(dist) > 100) {
                enemy.move(dist > 0 ? -0.4 : 0.4);
            } else {
                if (Math.random() > 0.95) enemy.attack(player.mainBody.position);
            }
            
            // Boundary checks
            [player, enemy].forEach(p => {
                if (p.mainBody.position.x < 0) Body.setPosition(p.mainBody, { x: 20, y: p.mainBody.position.y });
                if (p.mainBody.position.x > CONFIG.width) Body.setPosition(p.mainBody, { x: CONFIG.width - 20, y: p.mainBody.position.y });
            });
        });

        // --- COLLISION DAMAGE ---
        Events.on(engine, 'collisionStart', (event) => {
            event.pairs.forEach(pair => {
                const bodies = [pair.bodyA, pair.bodyB];
                const isEnemyPart = bodies.some(b => enemy.composite.bodies.includes(b));
                const isPlayerPart = bodies.some(b => player.composite.bodies.includes(b));
                
                if (isEnemyPart && isPlayerPart && pair.collision.depth > 2) {
                    const damage = pair.collision.depth * 2;
                    if (pair.bodyA.speed > 5 || pair.bodyB.speed > 5) {
                        // Determine who hit whom based on speed
                        if (player.mainBody.position.x < enemy.mainBody.position.x) {
                            enemy.health -= damage;
                        } else {
                            player.health -= damage;
                        }
                        updateUI();
                    }
                }
            });
        });

        function updateUI() {
            document.getElementById('p1-health').style.width = Math.max(0, player.health) + '%';
            document.getElementById('p2-health').style.width = Math.max(0, enemy.health) + '%';
            
            if (player.health <= 0 || enemy.health <= 0) {
                alert(player.health <= 0 ? "ENEMY WINS!" : "PLAYER WINS!");
                location.reload();
            }
        }

    </script>
</body>
</html>
